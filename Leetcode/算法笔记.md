# 复杂度

## 1.时间复杂度

### 定义：对于程序大致运行时间的描述

if语句:O(1)

for循环:n次单独的操作 O(n)

两层循环: O(n^2)

1e8:大约1s

## 2.空间复杂度

### 定义：对于程序大致运行空间的描述

一个int型变量所占空间大小为4byte=4b
题目中经常出现的空间限制 128mb，256mb
1mb = 1024kb
1kb = 1024b
1mb = 1024*1024b = 1e6b

1mb可以有 2.5*10^5个int变量

# 滑动窗口算法 Sliding Window
通过在数据结构（如数组、字符串）上维护一个窗口，来减少不必要的重复计算，从而提高效率。窗口可以是固定大小的，也可以是可变大小的。滑动窗口通常有两个指针（或索引）来表示窗口的左右边界，这两个指针会随着算法的进行在数据结构上滑动，计算结果。

## 滑动窗口的类型

### 固定大小的滑动窗口：
这种情况下，窗口的大小是固定的，通常用于查找固定大小子数组的最大值、最小值、和等。
例如：查找数组中所有长度为 k 的子数组的最大和。

### 可变大小的滑动窗口：
这种情况下，窗口的大小是动态变化的，通常用于查找满足某些条件的最小或最大子数组。
例如：在数组中查找和为某个值的最短子数组。

## 滑动窗口的工作原理

### 1.初始化窗口
选择起始位置，初始化窗口大小，并计算初始值（如初始窗口的和、最大值等）。

### 2.移动窗口：
移动窗口，即将窗口向前滑动一位。这通常涉及以下操作：

从窗口的左端移出一个元素。
在窗口的右端加入一个新元素。
更新窗口内的值，如当前窗口的和、最大值等。

### 3.更新结果：
在每次移动窗口后，检查并更新所需的结果（如最大和、最小和等）。

```C++
class Solution {
    public int maxSumOfFixedWindow(int[] nums, int k) {
        int n = nums.length;
        if (n < k) {
            throw new IllegalArgumentException("Array length must be at least " + k);
        }

        // 初始化窗口和最大和
        int maxSum = 0;
        for (int i = 0; i < k; i++) {
            maxSum += nums[i];
        }

        int currentSum = maxSum;

        // 滑动窗口遍历数组
        for (int i = k; i < n; i++) {
            currentSum = currentSum - nums[i - k] + nums[i];
            maxSum = Math.max(maxSum, currentSum);
        }

        return maxSum;
    }
}

```

# 哈希表

# 二分查找

## 问题引入：返回有序数组中第一个>=8的数的位置

### 高效做法：L和R分别指向询问的左右边界

### 写法（左开右开）

```C++
class Solution {
    // lower_bound 返回最小的满足 nums[i] >= target 的下标 i
    // 如果数组为空，或者所有数都 < target，则返回 nums.size()
    // 要求 nums 是非递减的，即 nums[i] <= nums[i + 1]
    int lower_bound(vector<int>& nums, int target) {
        int left = -1, right = nums.size(); // 开区间 (left, right)
        while (left + 1 < right) { // 区间不为空
            // 循环不变量：
            // nums[left] < target
            // nums[right] >= target
            int mid = left + (right - left) / 2; //防止溢出
            if (nums[mid] >= target) {
                right = mid; // 范围缩小到 (left, mid)
            } 
            else {
                left = mid; // 范围缩小到 (mid, right)
            }
        }
        // 循环结束后 left+1 = right
        // 此时 nums[left] < target 而 nums[right] >= target
        // 所以 right 就是第一个 >= target 的元素下标
        return right;
    }
};
```

### 四种情况
上题是>=,而对于>,<=,<又应该怎么操作？

对于整数数组来说：
1）>target 等价于 ≥ target+1
2）<=target 等价于 (>target)的左边那个数
3）<target 等价于 (≥ target)的左边那个数